# teh

## a simpler less versatile sed

teh [whole / lines 1, 2, 3.../ xthlines] [insert "" at x/delete x at x]

apply changes to
  - whole text
  - these particular lines in the text
  - every nth line

insert "" at x
  - insert given text at index number x
    - x is after x characters, -x is before last x-1 characters
    - 0 is before first character, -1 is after last character
                                   -2 is before last character
                                   -3 is before last two charactes

delete x to y
  - delete y chars skipping first x
    - x 0 will never delete anything, is basically an id
    - 0 -x will delete nothing because there are no letters to delete before the first letter
    - -1 5 like wise will only delete the last character because that is the last character to be deleted
       rem never loops around
    - 0 2 will start at the beginning and delete the first 2 characters
    - 5 3 will skip first 5 characters then delete the next 3
    - 5 -3 will skip the first 5 characters, then delete the previous three
           effectively the same as 2 3
    - -3 2 will starting from the end skip the last 3 characters, then delete the firt two of those last 3 characters
    - -3 -2 will starting from the end skip the last 3 letters, then delete 2 letters before them
           effectively the same as -5 2

data AtomicChange = Ac Which What

data Which = Whole
           | Every Int

data What = Ins Text Int
          | Del Int Int



## Argument Parsing

-- check if entire argument can be read as an Edit
  -- if true then that is the Edit
-- else then check if argument can be read as an (Target, Change)
  -- if yes then \(x,y)->(x.[y]) or \x->(fst x, [snd x]) and use as the Edit
-- else then check if filter (`isSuffixOf` arg) $ keys macros is empty
  -- if so then can't parse argument as macro or edit
-- else let longestkey = takeLast 1 $ Data.List.sortOn T.length $ filter (`isSuffixOf` arg) $ keys macros to get the macro
with the longest key that is a suffix of the argument check if the arg==longestkey to see if the arg is just the macro name.
  -- if it is just the macro name then use the Edit associated with that key in the Macros
-- else check if dropEnd (length longestkey) arg can be read as a Target
  -- if so then use that Target with the [Changes] from the macro for the Edit
  -- if not then can't parse the arguement as macro or edit
