# teh

## a simpler less versatile sed

teh [whole / lines 1, 2, 3.../ xthlines] [insert "" at x/delete x at x]

apply changes to
  - whole text
  - these particular lines in the text
  - every nth line

insert "" at x
  - insert given text at index number x
    - x is after x characters, -x is before last x-1 characters
    - 0 is before first character, -1 is after last character
                                   -2 is before last character
                                   -3 is before last two charactes

delete x to y
  - delete y chars skipping first x
    - x 0 will never delete anything, is basically an id
    - 0 -x will delete nothing because there are no letters to delete before the first letter
    - -1 5 like wise will only delete the last character because that is the last character to be deleted
       rem never loops around
    - 0 2 will start at the beginning and delete the first 2 characters
    - 5 3 will skip first 5 characters then delete the next 3
    - 5 -3 will skip the first 5 characters, then delete the previous three
           effectively the same as 2 3
    - -3 2 will starting from the end skip the last 3 characters, then delete the firt two of those last 3 characters
    - -3 -2 will starting from the end skip the last 3 letters, then delete 2 letters before them
           effectively the same as -5 2

data AtomicChange = Ac Which What

data Which = Whole
           | Every Int

data What = Ins Text Int
          | Del Int Int



## Argument Parsing

-- check if entire argument can be read as an Edit
  -- if true then that is the Edit
-- else then check if argument can be read as an (Target, Change)
  -- if yes then \(x,y)->(x.[y]) or \x->(fst x, [snd x]) and use as the Edit
-- else then check if filter (`isSuffixOf` arg) $ keys macros is empty
  -- if so then can't parse argument as macro or edit
-- else let longestkey = takeLast 1 $ Data.List.sortOn T.length $ filter (`isSuffixOf` arg) $ keys macros to get the macro
with the longest key that is a suffix of the argument check if the arg==longestkey to see if the arg is just the macro name.
  -- if it is just the macro name then use the Edit associated with that key in the Macros
-- else check if dropEnd (length longestkey) arg can be read as a Target
  -- if so then use that Target with the [Changes] from the macro for the Edit
  -- if not then can't parse the arguement as macro or edit










OLDNOTES

kept in case i need them

  Macro are now Map Text Edit
  Edit is just newtype of ([Change], Target)
  macro can still be read in from .teh and read with the read instance
  new syntax will look like in .teh2

  need to write a funtion to parse each arg passed better than just read

  before all this strip all white space
  first check and see if arg == some index in macros
    if so load that macro else
  then check if arg can be read as a [Change]
    if so read it as the list of changes with the def target
  try to read a target from beginning of list
    if found,
       try to read rest as [ Change ]
        if so return that [Change] with the Target
        if not return error
    if not return error

lookForTarget :: Text -> Text -> Maybe Target
lookForTarget _ "" = Nothing
lookForTarget pre post =
  case (readMaybe (pre <> (T.head post))::Target) of
    Nothing -> lookForTarget (pre<>(T.head post)) (T.tail post)
    Just t -> Just t

  make a more substantial default .teh file
    -- bracketing, square bracketing, shaving off an amount, code comments
  polish this readme

TODO but like later in the future

  give Change a recursive constructor to refer to a macro or something?
    just want a macro to be able to call another macro in it's changes

  pretty printing funtion to show list of all in scope macros or errors associated with
    macro files to find
    solution: improve printMacros function

  better syntax for writing out macro files and parse error messages
    solution: write a proper parser for a simpler syntax and use it to replace readMaybe in seekMacs

  flag to add another place to read a macro file and add it's errors to --listmacros

  paramaterized macros
