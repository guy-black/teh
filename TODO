
- test to make sure everything works as it should
-- wordsandquo has a bug when parsing a quote of just space
  example raw text: whole fr " " -
-- should become the following [Text]
  ["whole", "fr", " ", "-"]
-- but instead becomes
  ["whole","fr","","","-"]
-- this is because wordsandquo starts with applying T.words to the input text, and then looks through that text for a
   word starting with a quote and looks ahead in the list for a word closing with a quote, and combines those words and
   their contents
-- however T.word throws away spaces thus T.words applied to the raw text above evaluates to
  ["whole", "fr", "\"", "\"", "-"]
-- solution is to rewrite wordsandquo without using T.words
  rough puedocode sketh would be

wordsandquo :: T.Text -> [T.Text] -> [T.Text]
wordsandquo "" acc = acc -- base case and allow us to assume that txt is nonempty to safely call T.head
wordsandquo txt acc =
  if T.head txt == ' ' then -- white space we can safely throw way
    wordsandquo (T.drop 1 txt) acc
  else if T.head txt == '"' then -- we're entering a quote
    let quo = takeUntil (=='"') T.unpack $ T.drop 1 txt in
     -- to take characters until you find a closing quote and then have the whole quote, whitespace and all
     -- but also add conditions to ensure the quote I match isn't escaped
     -- and to preserve current logic it should also make sure the quote is followed by whitespace but maybe I should
       -- drop that requirement.  dropping that would allow not adding a space in between the find and replace if both have to be
       -- quoted anyway and I think shouldn't break any thing else not sure
       -- so I could do echo "hoy hog" | teh -n 'each fr "y h""t d"' and save a keystroke if I want
       -- more importantly it would make this logic easier to implment
     wordsandquo rst (acc <+> (T.pack $ '"':quo))
   else -- entering a plain nonquote word
     -- ehh you get the idea, or atleat I hope I will when I get a chance to work more on this


- write a better description for readme
- write a pretty print macros function

- work out how to implement a stream editing mode
  - if you have a command that regularly prints data to stdout (eg vmstat 1 or exoutput) and pipe it into teh
    teh should apply edits to every thing it prints to stdout in real time then print it to std out
  - maybe could be done using hClose and Control.Concurrent.threadDelay, idk need to learn more how concurrent haskell works

# misc notes on necessity of -f flag
- but then what if the last and only argument is both a readable filename and a macro?
  this could mean apply that macro to all stdin or use it's contents as text to edit with no edits
  I could only read last arg as text to edit if there is more than one argument so if it's meant to be a macro
  it could be moved back to avoid confusion, but then what if the edits need to be a particular order?
  So I should add a -f flag to indicate a file to be read from

# thought on the trouble of adding a wrap around

so if we have teh -t foobar 'Whole Rem 3 5'
- without -w the standard behavior is clear, skip the first three chars, foo, and delete the last three, bar and
  stop there since nothign is left leaving only foo
- and with -w it's still clear we should skip foo and delete the last three bar, then for the last two wrap around and
  delete the first two characters fo leaving only o
but what if we have teh -t foobar Rem 8 5
- the 8 chars to skip exceeds foobar length by two, should the offset also loop around thust starting between fo and obar?
  or should it be a no op for starting outside the bounds of the word?

  if the off set is placed between fo and obar should all of obar be removed and then loop around to remove the f too leaving only o?


  at that point what is the practical point of -w?  it feels like creating unpredictable behavior just for the sake of adding a
  new feature to this genreal text modifying algorithm.  I can't personally see a reason why I'd prefer
    teh -w -t foobar 'Whole Rem 4 3' over teh -t foobar 'Whole Rem 0 1 Rem 4 2'
  I suppose for determined -t value the -w allows me to remove a change from the list and still be pretty sure of what's expected
  but in general the command without -w feels more explicit and unambiguous about the intended outcome for most noncontrived
  situations.

  If anyone says they think the -w flag would be helpful and would like to define clear rules for how it should behave then
  I will implement it.  Hell I'd be over the moon if anyone else even finds any use in this little tool at all.  For now
  I don't think I can gain any use for a -w flag so I'm scrapping that whole idea for now pending the existence of other people
  using this tool and wanting such a feature
